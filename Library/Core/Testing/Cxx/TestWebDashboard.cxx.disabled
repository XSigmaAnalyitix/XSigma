/**
 * @file TestWebDashboard.cxx
 * @brief Comprehensive test suite for Web dashboard monitoring system
 */

#include "Testing/xsigmaTest.h"
#include "memory/visualization/web_dashboard.h"
#include "memory/cpu/allocator.h"

#include <memory>
#include <iostream>

using namespace xsigma;

namespace {

class test_dashboard_allocator : public Allocator
{
public:
    test_dashboard_allocator(const std::string& name) : name_(name) {}

    void* allocate_raw(size_t alignment, size_t num_bytes) override
    {
        return _aligned_malloc(num_bytes, alignment);
    }

    void* allocate_raw(size_t alignment, size_t num_bytes, const allocation_attributes& attrs) override
    {
        return allocate_raw(alignment, num_bytes);
    }

    void deallocate_raw(void* ptr) override { if (ptr) _aligned_free(ptr); }
    bool tracks_allocation_sizes() const noexcept override { return false; }
    size_t RequestedSize(const void* ptr) const noexcept override { return 0; }
    size_t AllocatedSize(const void* ptr) const noexcept override { return 0; }
    int64_t AllocationId(const void* ptr) const noexcept override { return 0; }

    std::optional<allocator_stats> GetStats() override
    {
        allocator_stats stats;
        stats.num_allocs = 100;
        stats.bytes_in_use = 1024 * 1024;
        stats.peak_bytes_in_use = 2048 * 1024;
        stats.largest_alloc_size = 4096;
        return stats;
    }

    std::string Name() override { return name_; }
    allocator_memory_enum GetMemoryType() const noexcept override
    {
        return allocator_memory_enum::HOST_PAGEABLE;
    }

private:
    std::string name_;
};

} // anonymous namespace

/**
 * @brief Test suite for Web dashboard functionality
 */
class WebDashboard : public ::testing::Test
{
protected:
    void SetUp() override
    {
        dashboard_ = std::make_unique<web_dashboard>();
        allocator_ = std::make_unique<test_dashboard_allocator>("test_allocator");
    }

    void TearDown() override
    {
        if (dashboard_ && dashboard_->is_running())
        {
            dashboard_->stop_dashboard();
        }
        dashboard_.reset();
        allocator_.reset();
    }

    std::unique_ptr<web_dashboard> dashboard_;
    std::unique_ptr<test_dashboard_allocator> allocator_;
};

/**
 * @brief Test allocator registration
 */
TEST_F(WebDashboard, allocator_registration)
{
    EXPECT_TRUE(dashboard_->register_allocator("test_alloc", allocator_.get()));
    EXPECT_FALSE(dashboard_->register_allocator("test_alloc", allocator_.get()));  // Duplicate
    EXPECT_FALSE(dashboard_->register_allocator("null_alloc", nullptr));  // Null

    auto registered = dashboard_->get_registered_allocators();
    EXPECT_EQ(registered.size(), 1);

    EXPECT_TRUE(dashboard_->unregister_allocator("test_alloc"));
    EXPECT_FALSE(dashboard_->unregister_allocator("test_alloc"));  // Already removed
}

/**
 * @brief Test JSON metrics export
 */
TEST_F(WebDashboard, json_metrics_export)
{
    EXPECT_TRUE(dashboard_->register_allocator("json_alloc", allocator_.get()));

    std::string metrics_json = dashboard_->get_allocator_metrics_json("json_alloc");
    EXPECT_FALSE(metrics_json.empty());
    EXPECT_NE(metrics_json.find("\"name\""), std::string::npos);
    EXPECT_NE(metrics_json.find("json_alloc"), std::string::npos);

    std::cout << "\n=== JSON METRICS DEMONSTRATION ===\n";
    std::cout << metrics_json << std::endl;

    std::string summary = dashboard_->get_all_allocators_summary_json();
    EXPECT_FALSE(summary.empty());

    std::cout << "\n=== SUMMARY JSON DEMONSTRATION ===\n";
    std::cout << summary << std::endl;
}

/**
 * @brief Test Prometheus metrics export
 */
TEST_F(WebDashboard, prometheus_metrics_export)
{
    EXPECT_TRUE(dashboard_->register_allocator("prom_alloc", allocator_.get()));

    std::string prometheus = dashboard_->export_prometheus_metrics();
    EXPECT_FALSE(prometheus.empty());
    EXPECT_NE(prometheus.find("# HELP"), std::string::npos);
    EXPECT_NE(prometheus.find("memory_"), std::string::npos);

    std::cout << "\n=== PROMETHEUS METRICS DEMONSTRATION ===\n";
    std::cout << prometheus << std::endl;
}

/**
 * @brief Test dashboard configuration
 */
TEST_F(WebDashboard, configuration_management)
{
    auto config = dashboard_->get_config();
    EXPECT_EQ(config.port, 8080);  // Default port
    EXPECT_TRUE(config.enable_websocket);

    web_dashboard::dashboard_config new_config;
    new_config.port = 9090;
    new_config.enable_websocket = false;
    dashboard_->set_config(new_config);

    auto updated = dashboard_->get_config();
    EXPECT_EQ(updated.port, 9090);
    EXPECT_FALSE(updated.enable_websocket);
}

/**
 * @brief Test comprehensive dashboard demonstration
 */
TEST(WebDashboardDemo, comprehensive_demonstration)
{
    std::cout << "\n" << std::string(60, '=') << "\n";
    std::cout << "WEB DASHBOARD DEMONSTRATION\n";
    std::cout << std::string(60, '=') << "\n";

    web_dashboard dashboard;
    auto gpu_alloc = std::make_unique<test_dashboard_allocator>("GPU_Memory");
    auto cpu_alloc = std::make_unique<test_dashboard_allocator>("CPU_Memory");

    EXPECT_TRUE(dashboard.register_allocator("gpu", gpu_alloc.get()));
    EXPECT_TRUE(dashboard.register_allocator("cpu", cpu_alloc.get()));

    std::cout << "\n1. REGISTERED ALLOCATORS:\n";
    auto registered = dashboard.get_registered_allocators();
    for (const auto& name : registered)
    {
        std::cout << "- " << name << "\n";
    }

    std::cout << "\n2. JSON EXPORT:\n";
    std::cout << dashboard.get_allocator_metrics_json("gpu") << "\n";

    std::cout << "\n3. PROMETHEUS EXPORT:\n";
    std::cout << dashboard.export_prometheus_metrics() << "\n";

    std::cout << std::string(60, '=') << "\n";
    EXPECT_TRUE(true);
}
